---
title: 과제할때 도움된 내용
create_date: 2024-06-05 17:06 - 2024-06-05 17:06
draft: false
---
### 파일 입출력에 대하여

^5c6d43

- 파일을 열면(open) 항상 닫아(close) 주어야 한다. with문을 써서 자동으로 처리되게 한다.
-  [with open구문에 대한 설명](https://starriet.medium.com/python-with-open-as-f-%EC%97%90%EC%84%9C-f%EC%9D%98-%EC%A0%95%EC%B2%B4%EB%8A%94-3cb48ea9e302)
```python
with A as B:
	...
```

A = '`context manager`'가 되는 객체이고
B = '`A.__enter__메서드의 리턴값`'이 된다.
- `with`구문이 시작될 때 이 `__enter__`메서드가 호출되며, `with`구문이 빠져나가면서 `__exit__`메서드가 자동으로 호출되는 것이다.
	- `with`구문에서 `open`함수를 사용할 때 굳이 `file object`를 `close()`헤주지 않아도 되는 이유이다.
```python
with open(...) as f:
	...
```

에서 `open(...)`함수가 리턴하는 객체는 `file object`인데, 이 객체는 `__enter__`와`__exit__` 메서드를 가지고 있도록 만들어져 있기 때문에 `context manager`역할하게 된다.

이 객체(`open함수가 리턴하는 file object`)의 `__enter__`메서드는 리턴값이 `self`이다. 
	- `file object` 자신을 리턴하므로 
	- `with open(...) as f`에서 `f`는 `open(...)`함수가 리턴한 `file object`가 된다.

---
### json.dump와 json.dumps의 차이 & json.loads에 대하여
#### json.dump, json.dumps
- `json.dump`: Python 객체를 JSON 형식으로 변환하여 <U>파일에 기록</U>한다.
	- 딕셔너리 자료형을 JSON 파일로 생성
- `json.dumps`: Python 객체를 <U>JSON 형식의 문자열</U>로 변환한다.
	- `dumps`함수는 python 객체를 한줄의(직렬화) json 문자열로 변환
	- 리스트나 튜플도 JSON 문자열로 바꿀 수 있다.
- `dump`와 `dumps`의 차이는 두번째 인자 `fp`에 있다.
	- `dump`는 첫번째 인자를 `open`한 file 안으로 바로 쓰기를 한다.
	- `dumps`는 파일로 쓰는 게 아닌 파이썬 내에서 사용하기 위해 json 형식으로 string으로 반환을 한다.
		- 이를 바로 받아서 사용 가능, 파일내로 바로 저장 or `print` 
- `ensure_ascii=False`: 데이터를 저장할 때 아스키코드 형태로 변환하지 않겠다는 뜻, 아스키로 바꾸고 싶다면 `True`로 바꾼다.
- `indent`: JSON 문자열을 정렬할 때 쓰인다.

---
#### json.load, json.loads
- `json.load`함수는 <U>JSON 파일을 읽어들이는 함수</U>이다.
	- 읽은 데이터를 딕셔너리 자료형으로 반환한다.
- `json.loads`함수는 <U>JSON 형태의 문자열을 읽어들이는 함수</U>이다.
	- JSON 문자열을 딕셔너리로 변환할때 쓰임.

---
#### pandas.read_json
- [pandas.read_json 문서](https://pandas.pydata.org/docs/reference/api/pandas.read_json.html)
- `pandas.read_json(a valid JSON str, path object or file-like object)`를 넣어 `pandas object`로 만든다.

---
#### pandas.json_normalize
- [pandas.json_normalize 문서](https://pandas.pydata.org/docs/reference/api/pandas.json_normalize.html#pandas-json-normalize)
- `pandas.json_normalize()`는 중첩된 JSON데이터 (딕셔너리 안의 리스트/ list of nested dictionaries)를 평면화하여 dataframe으로 만드는 것
```python
# 예시
ex_data = [
    {"id": 1, "name": {"first": "Coleen", "last": "Volk"}},
    {"name": {"given": "Mark", "family": "Regner"}},
    {"id": 2, "name": "Faye Raker"},
]
pd.json_normalize(ex_data)
```

- 출력값
![](https://imgur.com/hZtj1BF.jpg)

---
### .find, .find_all 함수 이해하기
- tag 추출하기
#### find_all(tag, attributes, recursive, text, limit, keyword)
- tag, attributes
	- `.findAll("태그명","dict 형식의 속성")`
- recursive
	- `recursive` 가 `True`이면 `findAll`함수는 매개변수에 일치하는 태그를 찾아 자식, 자식의 자식까지 검색
	- `recursive`가 `False`이면 `findAll`함수는 문서의 최상위 태그만 검색
- text
	- `text`는 태그의 속성이 아니라 텍스트 콘텐츠가 일치하는 값을 찾음
- keyword
	- 특정 속성이 포함된 태그를 선택할 때 사용됨
- limit
	- 페이지의 항목 처음 몇개에만 관심이 있을 때 사용
	- 이 매개변수는 페이지에 나타난 순서대로 찾으며 그 순서가 원하는 바와 일치한다는 보장 X

#### find(tag, attributes, recursive, text, keyword)
- `findAll`과 비슷하지만 limit가 없음.
- `find`는 `findAll`을 호출하면서 limit가 1인 함수 -> 1개만 출력

---
### import re

- 파이썬에서 정규 표현식을 사용할 때, 내장 모듈 `re`를 사용한다.
#### 정규 표현식
- 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어
- 복잡한 문자열을 처리할 때 사용하는 기법
- 주로 문자열의 검색과 치환을 위한 용도로 쓰임

#### re 모듈의 함수

##### 1. match(패턴, 문자열, 플래그)
- `match()`는 문자열의 처음부터 시작해서 작성한 패턴이 일치하는지 확인한다.
```python
import re

print(re.match('a','an'))
print(re.match('a','ann'))
print(re.match('a','bba'))
print(re.match('a','ba'))

# 출력값
# <re.Match object; span=(0, 1), match='a'>
# <re.Match object; span=(0, 1), match='a'>
# None
# None
```

- 예시의 1,2,번의 시작은 a로 시작하여 매칭이 된 것으로 확인되는데, 3,4번은 시작이 b로 시작하여 매칭이 안된 것을 확인할 수 있습니다.

##### 2. search(패턴, 문자열, 플래그)
- `search()`는 `match()`와 유사하지만 패턴이 문자열의 처음부터 일치하지 않아도 괜찮습니다.
```python
import re

print(re.search('a','an'))
print(re.search('a','ann'))
print(re.search('a','bba'))
print(re.search('a','ba'))

# 출력값
# <re.Match object; span=(0, 1), match='a'>
# <re.Match object; span=(0, 1), match='a'>
# <re.Match object; span=(2, 3), match='a'>
# <re.Match object; span=(1, 2), match='a'>
```

- 패턴과 일치만 한다면 문자열의 시작과는 상관없이 전부 찾아서 결과를 반환해줍니다.

##### 3. findall(패턴, 문자열, 플래그)
- `findall()`은 <U>문자열 안에 맞는 케이스를 전부 찾아서 리스트로 반환</U>합니다.
```python
import re

print(re.findall('a','a'))
print(re.findall('a','aba'))
print(re.findall('a','baa'))
print(re.findall('aaa','aaaa'))
print(re.findall('aaa','aaaaaa'))
print(re.findall('\d','숫자123이 이렇게56 있다8'))
print(re.findall('\d+','숫자123이 이렇게56 있다8'))

# 출력값
# ['a']
# ['a', 'a']
# ['a', 'a']
# ['aaa']
# ['aaa', 'aaa']
# ['1', '2', '3', '5', '6', '8']
# ['123', '56', '8']
```

- 4번째 예시를 보면 패턴은 `aaa`이고 문자열은 `aaaa` 4개입니다. 해당 함수는 겹치는 것을 제공하지 않으므로 `aaa`를 3개 보여주는 형태가 아닌 1개만 보여주게 됩니다.
- 5번째 예시는 `a`가 6개 이므로 패턴에 해당하는 문자열이 2개 존재하여 `aaa`를 2번 리스트에 담아 반환합니다.

##### 4. finditer(패턴, 문자열, 플래그)
- `findall()`과 유사하지만 패턴에 맞는 문자열의 리스트가 아닌 iterator 형식으로 반환합니다.
```python
import re

re_iter = re.finditer('a', 'baa')
for s in re_iter:
    print(s)

# 출력값
# <re.Match object; span=(1, 2), match='a'>
# <re.Match object; span=(2, 3), match='a'>
```

- 해당 함수를 사용하는 목적은 <U>패턴에 맞는 문자열과 어느 위치에 존재 하는지를 확인</U>할 때 사용할 수 있습니다.

##### 5. fullmatch(패턴, 문자열, 플래그)
- `fullmatch()`는 문자열에 시작과 끝이 정확하게 패턴에 일치할 때 반환합니다. `match()`는 처음부터 패턴에 맞으면 반환을 하지만 해당 함수는 시작과 끝이 정확하게 일치해야 합니다.
```python
import re

print(re.fullmatch('a','a'))
print(re.fullmatch('a','aaa'))
print(re.fullmatch('a','ab'))
print(re.fullmatch('a','ba'))

# 출력값
# <re.Match object; span=(0, 1), match='a'>
# None
# None
# None
```

##### 6. split(패턴, 문자열, 최대 split 수, 플래그)
- `split`은 문자열에서 <U>패턴이 맞으면 이를 기점으로 리스트로 쪼개는 함수</U>입니다. 만약 3번째 인자(최대 split 수)를 지정하면 문자열을 지정한 수 만큼 쪼개고 그 수가 도달하면 쪼개지 않습니다.
```python
import re

print(re.split('a', 'abaabca'))
print(re.split('a','abaabca',2))
print(re.split('a', 'aaaaaa',3))

# 출력값
# ['', 'b', '', 'bc', '']
# ['', 'b', 'abca']
# ['', '', '', 'aaa']
```

##### 7. sub(패턴, 교체할 문자열, 문자열, 최대 교체 수, 플래그)
- `sub`는 문자열에 맞는 패턴을 2번째 인자(교체할 문자열)로 교체합니다. `split`의 최대 split 수와 동일하게 최대 교체 수를 지정하면 문자열에 맞는 패턴을 교체할 문자열로 교체하고 그 수가 도달하면 더이상 교체하지 않습니다.
```python
import re


print(re.sub('a','z','ab'))
print(re.sub('a','zxc','ab'))
print(re.sub('a','z','aaaab'))
print(re.sub('a','z','aaaab', 1)) # a를 z로 교체 한번

# 출력값
# zb
# zxcb
# zzzzb
# zaaab
```

_※나중에 쓸 일이 있을 때 더 추가_

---
