---
title: 과제할때 도움된 내용
create_date: 2024-06-05 17:06 - 2024-06-05 17:06
draft: false
tags:
  - "#WebCrawling"
  - "#Pandas"
---
### 파일 입출력에 대하여

^5c6d43

- 파일을 열면(open) 항상 닫아(close) 주어야 한다. with문을 써서 자동으로 처리되게 한다.
-  [with open구문에 대한 설명](https://starriet.medium.com/python-with-open-as-f-%EC%97%90%EC%84%9C-f%EC%9D%98-%EC%A0%95%EC%B2%B4%EB%8A%94-3cb48ea9e302)
```python
with A as B:
	...
```

A = '`context manager`'가 되는 객체이고
B = '`A.__enter__메서드의 리턴값`'이 된다.
- `with`구문이 시작될 때 이 `__enter__`메서드가 호출되며, `with`구문이 빠져나가면서 `__exit__`메서드가 자동으로 호출되는 것이다.
	- `with`구문에서 `open`함수를 사용할 때 굳이 `file object`를 `close()`헤주지 않아도 되는 이유이다.
```python
with open(...) as f:
	...
```

에서 `open(...)`함수가 리턴하는 객체는 `file object`인데, 이 객체는 `__enter__`와`__exit__` 메서드를 가지고 있도록 만들어져 있기 때문에 `context manager`역할하게 된다.

이 객체(`open함수가 리턴하는 file object`)의 `__enter__`메서드는 리턴값이 `self`이다. 
	- `file object` 자신을 리턴하므로 
	- `with open(...) as f`에서 `f`는 `open(...)`함수가 리턴한 `file object`가 된다.

---
### json.dump와 json.dumps의 차이 & json.loads에 대하여
#### json.dump, json.dumps
- `json.dump`: Python 객체를 JSON 형식으로 변환하여 <U>파일에 기록</U>한다.
	- 딕셔너리 자료형을 JSON 파일로 생성
- `json.dumps`: Python 객체를 <U>JSON 형식의 문자열</U>로 변환한다.
	- `dumps`함수는 python 객체를 한줄의(직렬화) json 문자열로 변환
	- 리스트나 튜플도 JSON 문자열로 바꿀 수 있다.
- `dump`와 `dumps`의 차이는 두번째 인자 `fp`에 있다.
	- `dump`는 첫번째 인자를 `open`한 file 안으로 바로 쓰기를 한다.
	- `dumps`는 파일로 쓰는 게 아닌 파이썬 내에서 사용하기 위해 json 형식으로 string으로 반환을 한다.
		- 이를 바로 받아서 사용 가능, 파일내로 바로 저장 or `print` 
- `ensure_ascii=False`: 데이터를 저장할 때 아스키코드 형태로 변환하지 않겠다는 뜻, 아스키로 바꾸고 싶다면 `True`로 바꾼다.
- `indent`: JSON 문자열을 정렬할 때 쓰인다.

---
#### json.load, json.loads
- `json.load`함수는 <U>JSON 파일을 읽어들이는 함수</U>이다.
	- 읽은 데이터를 딕셔너리 자료형으로 반환한다.
- `json.loads`함수는 <U>JSON 형태의 문자열을 읽어들이는 함수</U>이다.
	- JSON 문자열을 딕셔너리로 변환할때 쓰임.

---
#### pandas.read_json
- [pandas.read_json 문서](https://pandas.pydata.org/docs/reference/api/pandas.read_json.html)
- `pandas.read_json(a valid JSON str, path object or file-like object)`를 넣어 `pandas object`로 만든다.

---
#### pandas.json_normalize
- [pandas.json_normalize 문서](https://pandas.pydata.org/docs/reference/api/pandas.json_normalize.html#pandas-json-normalize)
- `pandas.json_normalize()`는 중첩된 JSON데이터 (딕셔너리 안의 리스트/ list of nested dictionaries)를 평면화하여 dataframe으로 만드는 것
```python
# 예시
ex_data = [
    {"id": 1, "name": {"first": "Coleen", "last": "Volk"}},
    {"name": {"given": "Mark", "family": "Regner"}},
    {"id": 2, "name": "Faye Raker"},
]
pd.json_normalize(ex_data)
```

- 출력값
![](https://imgur.com/hZtj1BF.jpg)

---
### .find, .find_all 함수 이해하기
- tag 추출하기
#### find_all(tag, attributes, recursive, text, limit, keyword)
- tag, attributes
	- `.findAll("태그명","dict 형식의 속성")`
- recursive
	- `recursive` 가 `True`이면 `findAll`함수는 매개변수에 일치하는 태그를 찾아 자식, 자식의 자식까지 검색
	- `recursive`가 `False`이면 `findAll`함수는 문서의 최상위 태그만 검색
- text
	- `text`는 태그의 속성이 아니라 텍스트 콘텐츠가 일치하는 값을 찾음
- keyword
	- 특정 속성이 포함된 태그를 선택할 때 사용됨
- limit
	- 페이지의 항목 처음 몇개에만 관심이 있을 때 사용
	- 이 매개변수는 페이지에 나타난 순서대로 찾으며 그 순서가 원하는 바와 일치한다는 보장 X

#### find(tag, attributes, recursive, text, keyword)
- `findAll`과 비슷하지만 limit가 없음.
- `find`는 `findAll`을 호출하면서 limit가 1인 함수 -> 1개만 출력

---
### import re

- 파이썬에서 정규 표현식을 사용할 때, 내장 모듈 `re`를 사용한다.
#### 정규 표현식
- 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어
- 복잡한 문자열을 처리할 때 사용하는 기법
- 주로 문자열의 검색과 치환을 위한 용도로 쓰임

#### re 모듈의 함수

##### 1. match(패턴, 문자열, 플래그)
- `match()`는 문자열의 처음부터 시작해서 작성한 패턴이 일치하는지 확인한다.
```python
import re

print(re.match('a','an'))
print(re.match('a','ann'))
print(re.match('a','bba'))
print(re.match('a','ba'))

# 출력값
# <re.Match object; span=(0, 1), match='a'>
# <re.Match object; span=(0, 1), match='a'>
# None
# None
```

- 예시의 1,2,번의 시작은 a로 시작하여 매칭이 된 것으로 확인되는데, 3,4번은 시작이 b로 시작하여 매칭이 안된 것을 확인할 수 있습니다.

##### 2. search(패턴, 문자열, 플래그)
- `search()`는 `match()`와 유사하지만 패턴이 문자열의 처음부터 일치하지 않아도 괜찮습니다.
```python
import re

print(re.search('a','an'))
print(re.search('a','ann'))
print(re.search('a','bba'))
print(re.search('a','ba'))

# 출력값
# <re.Match object; span=(0, 1), match='a'>
# <re.Match object; span=(0, 1), match='a'>
# <re.Match object; span=(2, 3), match='a'>
# <re.Match object; span=(1, 2), match='a'>
```

- 패턴과 일치만 한다면 문자열의 시작과는 상관없이 전부 찾아서 결과를 반환해줍니다.

##### 3. findall(패턴, 문자열, 플래그)
- `findall()`은 <U>문자열 안에 맞는 케이스를 전부 찾아서 리스트로 반환</U>합니다.
```python
import re

print(re.findall('a','a'))
print(re.findall('a','aba'))
print(re.findall('a','baa'))
print(re.findall('aaa','aaaa'))
print(re.findall('aaa','aaaaaa'))
print(re.findall('\d','숫자123이 이렇게56 있다8'))
print(re.findall('\d+','숫자123이 이렇게56 있다8'))

# 출력값
# ['a']
# ['a', 'a']
# ['a', 'a']
# ['aaa']
# ['aaa', 'aaa']
# ['1', '2', '3', '5', '6', '8']
# ['123', '56', '8']
```

- 4번째 예시를 보면 패턴은 `aaa`이고 문자열은 `aaaa` 4개입니다. 해당 함수는 겹치는 것을 제공하지 않으므로 `aaa`를 3개 보여주는 형태가 아닌 1개만 보여주게 됩니다.
- 5번째 예시는 `a`가 6개 이므로 패턴에 해당하는 문자열이 2개 존재하여 `aaa`를 2번 리스트에 담아 반환합니다.

##### 4. finditer(패턴, 문자열, 플래그)
- `findall()`과 유사하지만 패턴에 맞는 문자열의 리스트가 아닌 iterator 형식으로 반환합니다.
```python
import re

re_iter = re.finditer('a', 'baa')
for s in re_iter:
    print(s)

# 출력값
# <re.Match object; span=(1, 2), match='a'>
# <re.Match object; span=(2, 3), match='a'>
```

- 해당 함수를 사용하는 목적은 <U>패턴에 맞는 문자열과 어느 위치에 존재 하는지를 확인</U>할 때 사용할 수 있습니다.

##### 5. fullmatch(패턴, 문자열, 플래그)
- `fullmatch()`는 문자열에 시작과 끝이 정확하게 패턴에 일치할 때 반환합니다. `match()`는 처음부터 패턴에 맞으면 반환을 하지만 해당 함수는 시작과 끝이 정확하게 일치해야 합니다.
```python
import re

print(re.fullmatch('a','a'))
print(re.fullmatch('a','aaa'))
print(re.fullmatch('a','ab'))
print(re.fullmatch('a','ba'))

# 출력값
# <re.Match object; span=(0, 1), match='a'>
# None
# None
# None
```

##### 6. split(패턴, 문자열, 최대 split 수, 플래그)
- `split`은 문자열에서 <U>패턴이 맞으면 이를 기점으로 리스트로 쪼개는 함수</U>입니다. 만약 3번째 인자(최대 split 수)를 지정하면 문자열을 지정한 수 만큼 쪼개고 그 수가 도달하면 쪼개지 않습니다.
```python
import re

print(re.split('a', 'abaabca'))
print(re.split('a','abaabca',2))
print(re.split('a', 'aaaaaa',3))

# 출력값
# ['', 'b', '', 'bc', '']
# ['', 'b', 'abca']
# ['', '', '', 'aaa']
```

##### 7. sub(패턴, 교체할 문자열, 문자열, 최대 교체 수, 플래그)
- `sub`는 문자열에 맞는 패턴을 2번째 인자(교체할 문자열)로 교체합니다. `split`의 최대 split 수와 동일하게 최대 교체 수를 지정하면 문자열에 맞는 패턴을 교체할 문자열로 교체하고 그 수가 도달하면 더이상 교체하지 않습니다.
```python
import re


print(re.sub('a','z','ab'))
print(re.sub('a','zxc','ab'))
print(re.sub('a','z','aaaab'))
print(re.sub('a','z','aaaab', 1)) # a를 z로 교체 한번

# 출력값
# zb
# zxcb
# zzzzb
# zaaab
```

_※나중에 쓸 일이 있을 때 더 추가_

---
### `if __name__ == "__main__":`

#### 파이썬에서의 네임스페이스(namespace)

- namespace : 개체를 구분할 수 있는 범위
	- 어떤 객체를 이름으로 구분할 수 있는 범위를 의미

- 파이썬에서는 모든 것이 객체
	- 객체들은 각자의 이름을 가지고 구분할 수 있다.
	- 하지만, 객체를 이름만으로 구분 ❌
		- 모든 함수, 변수, 클래스등의 이름을 전부 다 다르게 설정해야함
		- ==불가능==
- <U>객체마다 자신의 영향력을 행사할 수 있는 범위를 제한하여 이름의 중복을 허용</U>

#### 파이썬에서 네임스페이스 3가지

1. 지역 네임스페이스(Local namespace) - **함수(메소드)별**로 구분되는 네임스페이스
2. 글로벌 네임스페이스(Global namespace) - **모듈 단위**로 구분되는 네임스페이스
3. 빌트인 네임스페이스(Built-in namespace) - **내장 함수를 포함한 전체 코드** 네임스페이스

- 어떤 객체를 참조하려고 할 때, 탐색 순서는 *지역 -> 글로벌 -> 빌트인* 순으로 탐색
	- 역순 참조는 ==불가능==

#### `if __name__ == "__main__"`의 기능

- `__name__`의 특징
```python
# test1.py
print(__name__)
# 출력값
__main__
```

-  파이썬 파일을 커맨드라인이나 인터페이스를 통해 직접 실행한 경우 `__name__`에는 `__main__`이라는 값(네임스페이스)이 설정됨

```python
# test2.py
import test1

print(test1.__name__)

# 출력값
test1
```

-  파이썬 파일을 모듈로서 사용, 즉 **다른 파일에서 불러와 사용하는 경우 `__name__`에는 모듈 이름이 설정됨

- `if __name__ == "__main__"`은 ***해당 구문이 사용된 파이썬 파일을 직접 실행했을때만 아래 코드를 실행하겠다*** 라는 뜻

- 예시
```python
# test1.py
print("메롱")

# test2.py
import test1

print("ㅎㅇ")

# 출력값
메롱
ㅎㅇ
```
- `test1`에 있던 print문이 출력되는 모습이다.

```python
# test1.py
if __name__ == "__main__":
		print("메롱")
```

- `test1`모듈에 위와 같이 `__name__`을 이용한 구문을 넣어주면 모듈이 import 되면서 실행되는 참사를 막을 수 있다.

---
### 텍스트 전처리(정규 표현식)

```python
import re

for i in range(len(df_reviews)):
    text = temp_reviews['Review_Text'][i]
    if not isinstance(text, str):
        text = str(text)
    # 1번
    temp = re.sub('[^가-힣a-zA-Z0-9\s]', '',text)

	# 2번
    temp = re.sub('[ㄱ-하-ㅣ]', '', text)

	# 3번
    temp = re.sub('[^\w\s]', '', text)

	# 4번
    temp = re.sub('[ㄱ-ㅎ()]', '',text)

	# 5번
    temp = re.sub('[\n]', '', text)

	# 6번
    temp = re.sub(r"\n", '', text)

	# 7번
    temp = re.sub('[^,.?!\w\s]', '', text)

    print(temp)

    temp_reviews.loc[[i],['Review_Text']] = temp
```

1. `re.sub('[^가-힣a-zA-Z0-9\s]', '', text)`
	-  한글 문자(가-힣), 영어 알파벳(대소문자), 숫자(0-9), 공백 문자가 아닌 모든 문자를 빈 문자열(`''`)로 대체
	- 이 문자들을 제외한 모든 문자를 제거
	- 제일 많이 쓰임
2. `re.sub('[ㄱ-ㅎㅏ-ㅣ]', '', text)`
	- 한글 자음과 모음 문자를 문자열에서 제거
	- `ㄱ-ㅎ` : 한글 자음 ㄱ부터 ㅎ까지
	- `ㅏ-ㅣ`: 한글 모음 ㅏ 부터 ㅣ까지
3. `re.sub('[^\w\s]', '', text)`
	- 단어 문자(`\w`) 즉, 알파벳, 숫자, 밑줄(`_`) 문자와 공백 문자 (`\s`)가 아닌 모든 문자를 빈 문자열(`''`)로 대체.
	- 구두점이나 특수 문자를 제거 (밑줄은 제거 ❌)
4. `re.sub('[ㄱ-ㅎ()]', '', text)`
	- 한글 자음(ㄱ-ㅎ) 및 괄호 문자 (`(`와`)`)를 빈 문자열(`''`)로 대체
5. `re.sub('[\n]', '', text)`
	- 줄바꿈 문자(`\n`)를 빈 문자열(`''`)로 대체
	- 줄바꿈 문자(개행 문자)를 제거
6. `re.sub(r"\n", '', text)`
	- 줄바꿈 문자 제거
	- `r""`는 raw string으로, 백슬래시를 있는 그대로 처리
7. `re.sub('[^,.?!\w\s]', '', text)`
	- 쉼표`,`, 마침표`.`, 느낌표`!`, 물음표`?`, 단어 문자`\w`, 공백 문자`\s`가 아닌 모든 문자를 빈 문자열(`''`)로 대체
	- 지정된 구두점, 단어 문자 및 공백 문자를 제외한 모든 문자를 제거

#### HTML 태그 제거
1. `re.sub(r'<(.*?)>', '', text)`

```python
import re

text = "탑텐 남성 쿨에어 코튼 <b>반팔 티</b> 오버핏 MSD2TS1001"

# HTML 태그 제거
clean_text = re.sub(r'<(.*?)>', '', text)

print(clean_text)

# 출력값
탑텐 남성 쿨에어 코튼 반팔 티 오버핏 MSD2TS1001
```

2. `re.sub('<[^>]+>', '', text)`

```python
import re

text = "탑텐 남성 쿨에어 코튼 <b>반팔 티</b> 오버핏 MSD2TS1001"

# HTML 태그 제거
clean_text = re.sub('<[^>]+>', '', text)

print(clean_text)

# 출력값
# 문자열로 나옴
'탑텐 남성 쿨에어 코튼 반팔 티 오버핏 MSD2TS1001'
```

#### 특수 기호 제거
1. `re.sub('[^\w\s]', '', text)`

```python
import re

text = "과거에서 '교훈'!!!을 얻을 수는 있어도, 과거 속에 살 수는 없다.^.^"

# 특수 기호 제거
clean_text = re.sub('[^\w\s]', '', text)

print(clean_text)

# 출력값
과거에서 교훈을 얻을 수는 있어도 과거 속에 살 수는 없다
```